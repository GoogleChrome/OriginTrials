<!doctype html>
<meta charset="utf-8">
<title>Check an Origin Trial token</title>
<meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
<style>
 th { text-align: right; }
 #validity { color: #000; background-color: #8f8; }
 #validity.invalid { color: #fff; background-color: #f00; }
 #host.hidden { display: none; }
</style>

<h1>Check an Origin Trial token</h1>

<p>
  <label>Paste the token here<br>
    <textarea id="token" placeholder="Token" autofocus cols="50" rows="6"></textarea>
  </label><br>
  <label id="host" class="hidden">Paste the host here<br>
    <textarea id="host-text" placeholder="Host" autofocus cols="50" rows="1"></textarea>
  </label>
</p>

<table>
  <tr><th>Valid?</th><td><span id="validity"></span></td></tr>
  <tr><th>Version</th><td><span id="version"></span></td></tr>
  <tr><th>Origin</th><td><span id="origin"s></span></td></tr>
  <tr><th>Matches Subdomains?</th><td><span id="subdomain"></span></td></tr>
  <tr><th>Is Host Subdomain?</th><td><span id="host-validity"></span></td></tr>
  <tr><th>Feature</th><td><span id="feature"></span></td></tr>
  <tr><th>Expires</th><td><span id="expiry"></span></td></tr>
</table>

<script type="text/javascript"
        src="https://cdn.rawgit.com/tonyg/js-nacl/09d04c712117961a21aebf9c4735eb04f05ea79e/lib/nacl_factory.js"
        crossorigin="anonymous"
        integrity="sha384-k1LT12bBTLMRe+VRFdE0F4iaPU3RO5oSILEsw4TJ8eNtzZLlMuWY4MShH79NAmU8">
</script>

<script>
 // From https://cs.chromium.org/chromium/src/chrome/common/origin_trials/chrome_origin_trial_policy.cc
 // as of 2016-09-07.
 const kDefaultPublicKey = new Uint8Array([
   0x7c, 0xc4, 0xb8, 0x9a, 0x93, 0xba, 0x6e, 0xe2, 0xd0, 0xfd, 0x03,
   0x1d, 0xfb, 0x32, 0x66, 0xc7, 0x3b, 0x72, 0xfd, 0x54, 0x3a, 0x07,
   0x51, 0x14, 0x66, 0xaa, 0x02, 0x53, 0x4e, 0x33, 0xa1, 0x15,
 ]);

 const tokenElem = document.getElementById("token");
 const hostElem = document.getElementById("host");
 const hostTextElem = document.getElementById("host-text");
 const validityElem = document.getElementById("validity");
 const versionElem = document.getElementById("version");
 const originElem = document.getElementById("origin");
 const subdomainElem = document.getElementById("subdomain");
 const hostValidityElem = document.getElementById("host-validity");
 const featureElem = document.getElementById("feature");
 const expiryElem = document.getElementById("expiry");

 let nacl;
 nacl_factory.instantiate(readyNacl => { nacl = readyNacl; });

 const utf8Decoder = new TextDecoder("utf-8", {fatal: true});

 // From https://cs.chromium.org/chromium/src/url/url_util.cc
 // as of 2019-05-14.
 function domainIs(canonicalHost, canonicalDomain) {
   if (typeof canonicalHost !== 'string' || typeof canonicalDomain !== 'string') {
     return false;
   }

   if (canonicalHost === "" || canonicalDomain === "") {
     return false;
   }

   try {
     canonicalHost = new URL(canonicalHost).hostname;
     canonicalDomain = new URL(canonicalDomain).hostname;
   } catch(e) {
     return false;
   }

   let hostLen = canonicalHost.length;
   if (canonicalHost[canonicalHost.length - 1] === '.' &&
       canonicalDomain[canonicalDomain.length - 1] !== '.') {
     --hostLen;
   }

   if (hostLen < canonicalDomain.length) {
     return false;
   }

   const hostFirstPos = hostLen - canonicalDomain.length;
   const hostSub = canonicalHost.slice(hostFirstPos, hostFirstPos + canonicalDomain.length);
   if (hostSub !== canonicalDomain) {
     return false;
   }

   if (canonicalDomain[0] !== '.' &&
       hostLen > canonicalDomain.length && canonicalHost[hostFirstPos -1] !== '.') {
     return false;
   }

   return true;
 }

 function validate() {
   hostElem.classList.add("hidden");
   validityElem.textContent = "";
   validityElem.classList.add("invalid");
   originElem.textContent = "";
   subdomainElem.textContent = "";
   hostValidityElem.textContent = "";
   featureElem.textContent = "";
   expiryElem.textContent = "";

   // Base64-decode the token into a Uint8Array.
   let tokenStr;
   try {
     tokenStr = atob(tokenElem.value);
   } catch(e) {
     console.error(e);
     validityElem.textContent = "Invalid Base64";
     return;
   }
   const token = new Uint8Array(tokenStr.length);
   for (let i = 0; i < token.length; i++) {
     token[i] = tokenStr.charCodeAt(i);
   }

   // Check that the version number is 2.
   console.log(token);
   const version = token[0];
   versionElem.textContent = "" + version;
   if (version !== 2) {
     validityElem.textContent = "Unknown version";
     return;
   }

   // Pull the fields out of the token.
   if (token.length < 69) {
     validityElem.textContent = "Token is too short";
     return;
   }
   const signature = new Uint8Array(token.buffer, 1, 64);
   const payloadLength = new DataView(token.buffer, 65, 4).getInt32(0, /*littleEndian=*/false);
   const payload = new Uint8Array(token.buffer, 69);
   if (payload.length !== payloadLength) {
     validityElem.textContent =
         "Token is " + payload.length + " bytes; expected " + payloadLength;
     return;
   }

   // The version + length + payload is signed.
   const signedData = new Uint8Array(token.buffer.slice(64));
   signedData[0] = token[0];

   // Check the ED25519 signature.
   if (!nacl.crypto_sign_verify_detached(signature, signedData, kDefaultPublicKey)) {
     validityElem.textContent = "Invalid signature";
     return;
   }

   // Pull the fields out of the JSON payload.
   let json;
   try {
     json = utf8Decoder.decode(payload);
   } catch(e) {
     console.error(e);
     validityElem.textContent = "Invalid UTF-8";
     return;
   }
   console.log("Token JSON", json);

   let obj;
   try {
     obj = JSON.parse(json);
   } catch(e) {
     console.error(e);
     validityElem.textContent = "Invalid JSON";
     return;
   }

   originElem.textContent = obj.origin;
   subdomainElem.textContent = obj.isSubdomain ? "Yes" : "No";
   featureElem.textContent = obj.feature;

   if (obj.isSubdomain) {
     hostElem.classList.remove("hidden");
   }

   const hostElemIsChanged = hostTextElem.value !== hostTextElem.defaultValue;
   if (obj.isSubdomain && hostElemIsChanged) {
     hostValidityElem.textContent = domainIs(hostTextElem.value, obj.origin) ? "Yes" : "No";
   }

   let expiry;
   try {
     expiry = parseInt(obj.expiry);
   } catch(e) {
     console.error(e);
     validityElem.textContent = "Expiry value wasn't an integer";
     expiryElem.textContent = obj.expiry;
     return;
   }

   let expiryDate = new Date(expiry * 1000);
   expiryElem.textContent = expiryDate.toLocaleString();
   if (expiryDate < new Date()) {
     validityElem.textContent = "Expired"
     return;
   }

   validityElem.classList.remove("invalid");
   validityElem.textContent = "Valid";

 }

 tokenElem.oninput = validate;
 hostElem.oninput = validate;
</script>
